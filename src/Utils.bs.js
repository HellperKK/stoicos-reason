// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function list_slice(min, max, liste) {
  var aux = function (_acc, _i) {
    while(true) {
      var i = _i;
      var acc = _acc;
      var match = i === max;
      if (match) {
        return acc;
      } else {
        _i = i + 1 | 0;
        _acc = /* :: */[
          List.nth(liste, i),
          acc
        ];
        continue ;
      }
    };
  };
  return List.rev(aux(/* [] */0, min));
}

function list_fetch(liste, index, $$default) {
  try {
    return List.nth(liste, index);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    var exit = 0;
    if (exn[0] === Caml_builtin_exceptions.invalid_argument && exn[1] === "List.nth") {
      return $$default;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (exn[0] === Caml_builtin_exceptions.failure) {
        if (exn[1] === "nth") {
          return $$default;
        } else {
          throw exn;
        }
      } else {
        throw exn;
      }
    }
    
  }
}

function list_same_size(liste, listeb, $$default) {
  return List.mapi((function (index, _) {
                return list_fetch(listeb, index, $$default);
              }), liste);
}

function list_first(f, _liste) {
  while(true) {
    var liste = _liste;
    if (liste) {
      var head = liste[0];
      if (Curry._1(f, head)) {
        return Js_primitive.some(head);
      } else {
        _liste = liste[1];
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function string_slice(min, max, chaine) {
  var size = max - min | 0;
  return $$String.sub(chaine, min, size);
}

function find_first_char(car, chaine) {
  var _i = 0;
  while(true) {
    var i = _i;
    var x = Caml_string.get(chaine, i);
    if (x === car) {
      return i;
    } else if (i === (chaine.length - 1 | 0)) {
      return undefined;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function string_split(car, chaine) {
  var match = find_first_char(car, chaine);
  if (match !== undefined) {
    var i = match;
    return /* :: */[
            $$String.sub(chaine, 0, i),
            string_split(car, $$String.sub(chaine, i + 1 | 0, (chaine.length - i | 0) - 1 | 0))
          ];
  } else {
    return /* :: */[
            chaine,
            /* [] */0
          ];
  }
}

function super_int_of_string(chaine) {
  try {
    return Caml_format.caml_int_of_string(chaine);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      if (exn[1] === "int_of_string") {
        return 0;
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

function super_float_of_string(chaine) {
  try {
    return Caml_format.caml_float_of_string(chaine);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      if (exn[1] === "float_of_string") {
        return 0.0;
      } else {
        throw exn;
      }
    } else {
      throw exn;
    }
  }
}

exports.list_slice = list_slice;
exports.list_fetch = list_fetch;
exports.list_same_size = list_same_size;
exports.list_first = list_first;
exports.string_slice = string_slice;
exports.find_first_char = find_first_char;
exports.string_split = string_split;
exports.super_int_of_string = super_int_of_string;
exports.super_float_of_string = super_float_of_string;
/* No side effect */
